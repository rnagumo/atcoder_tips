
"""
https://atcoder.jp/contests/abc140/tasks/abc140_d

向かい合っている要素cnt，もしくは前に何もない要素edge，の数を数える．
すると，N - 2 * cnt - edgeが，初期状態の答えになる．
このうち，K回の操作により，一回あたり2だけ答えを増やすことができる．
また，全ての要素が同じ文字である時が最善であり，その時の答えはN-1である．
．
まずは，配列の中にある向かい合う要素を解消していく．この操作はcnt回までできる．
次に，edgeの向きを変える．ただし，片方のみが条件を満たすことになる．
しかし，答えの最大値がN-1で制限されているので，こちらで修正される．

また，Kが大きい場合には，最大値N-1に到達するので，それで制限をかけておけばよい．
"""

N, K = map(int, input().split())
S = input()

cnt = S.count("RL")
edge = int(S[0] == "L") + int(S[-1] == "R")

print(min(N - 1, N - 2 * cnt - edge + K * 2))
